# I/O模型
* 计算机的重要工作之一便是负责各种设备的数据输入/输出，这个就是前面经常提到的I/O操作。
* I/O操作根据设备的不同分为很多种类型，例如内存I/O、网络I/O、磁盘I/O。
* 一般的性能瓶颈集中于网络I/O和磁盘I/O
问题1：为啥网络I/O和磁盘I/O的速度相较于内存I/O要慢很多？
问题2：网络I/O和磁盘I/O需要CPU来调度，内存I/O不需要吗？

* 磁盘和内存之间数据传输使用DMA（直接内存访问）模式，CPU只需要想DMA控制器下达指令，让DMA控制器来处理数据的传输即可，DMA控制器通过系统总线来传输数据，传送完毕后再通知CPU，从而大大降低了CPU占有率，节省系统资源。
问题3：系统总线的概念

同步阻塞I/O，进程等待时间：一、等待数据的就绪，二、等待数据的复制。
同步非阻塞I/O，一、通过反复轮询查看数据是否就绪，二、等待数据的复制，一般针对网络I/O。
多路I/O就绪通知，允许进程通过一种方法来同时监视所有文件描述符，并可以快速获得所有就绪的文件描述符，即进程可以通过这种方法监听到数据是否就绪，解决了同步非阻塞I/O需要反复轮询来查询数据是否就绪时消耗的CPU时间，
问题4：网络I/O是指网卡数据的输入输出吗？
问题5：什么是文件描述符？

# 内存映射
1、概念：Linux内核提供一种访问磁盘文件的特殊方式，可以将内存中某块地址空间和我们要指定的磁盘文件相关联，从而把对内存的访问转换为对磁盘文件的访问。
问题1：为啥能提高磁盘I/O的性能？
> 在大多数情况下，使用内存映射可以提高磁盘I/O的性能

2、有两种类型的内存映射，共享型和私有型。
共享型：可以将任何对内存的写操作都同步到磁盘文件，而且所有映射同一个文件的进程都共享任意一个进程对映射内存的修改，即多个进程会同步修改磁盘文件的内容（我理解的对不对？）
私有型：映射的文件只能是制度文件，所以不可以将对内存的写同步到文件，且多个进程不共享修改。
显然，共享型的效率偏低。

# 直接I/O
前面所学的知识得知，应用程序发送数据时需要将数据从内存区复制到内核缓冲区，引入内核缓冲区的目的是为了提高磁盘文件的访问性能。因为当进程需要读取磁盘文件时，如果文件已经在内核缓冲区就不需要再次访问磁盘了；而进程需要向文件写入数据，实际只写到了内核缓冲区便告诉进程已成功，后续再通过一定的策略延迟写入磁盘。
有些复杂的应用，例如数据库服务器，为了充分提高性能，希望绕过内核缓冲区，由自己在用户态空间实现并管理I/O缓冲区，包括缓存机制和写延迟机制等，这种方式称为直接I/O。

问题1：raw分区是什么？去了解分区格式

> 大多数时候，我们都在向 Web 服务器请求静态文件，比如图片、样式表等，根据前面的介绍，我们知道在处理这些请求的过程中，磁盘文件的数据先要经过内核缓冲区，然后到达用户内存空间，因为是不需要任何处理的静态数据，所以它们又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。
数据从内核出去，绕了一圈，又回到内核，没有任何变化，看起来真是浪费时间。

问题2：上文中的意思是内核缓冲区与网卡的内核缓冲区是同一个东西？
思考：网卡内核缓冲区与数据存储的内核缓冲区是同一个东西，都是在内核中，只是分别对应的缓冲区不同，文中的意思是不需要进行处理的静态文件数据可以简化数据发送的流程，可以减少内核态的切换和用户态复制的开销。


阻塞和非阻塞前面讲过，是指当前进程访问的数据如果尚未就绪，进程是否等待就绪还是直接返回结果；
同步和异步是指访问数据的机制。
同步I/O：主动请求并等待I/O操作完毕的方式，当数据就绪后在读写的时候必须阻塞。
异步I/O：主动请求数据后便可以继续处理其他任务，随后等待I/O操作完毕的通知，可以使进程在数据读写时不发生阻塞。
问题1：同步I/O，数据都准备就绪了再进行读写时为什么会发生阻塞？



