
## 背景
在实际应用中，使用页面缓存显得尤为笨重，原因有：
* 网页中的不同区域内容的更新频率与呈现及时度要求不同；
* 即便是采用局部动态缓存，如果局部区域过多则会使页面过于复杂，且整合各个局部页面也存在不小开销；
* 不是页面上所有东西都能作为页面缓存，例如用户登录状态下的页面呈现；
* 页面缓存只提高了读数据的速度，没有提高写数据的速度。

## 数据库的前端缓存区
在数据库服务器上利用文件系统内核缓冲区，用于加速数据库的读写操作。
它包括两部分组成：读缓存区和写缓存区
读缓存区中保存着最近系统从磁盘上读取的数据，一旦下次需要读取这些数据时内核直接从这里获取，不需要访问磁盘。
写缓存区的目的主要在于减少磁盘的物理写操作，通常情况下向磁盘中写入数据并不着急，进程不需要因为写操作而等待，内核缓冲区可以将多次写操作的指令累积起来通过统一的一次物理磁头的移动来完成。写缓冲区很像生活中的红绿灯，通过红灯等待时间的积累，变绿灯后车辆依次通过，使得各个方向通行都井然有序。

## 分布式缓存系统
目前主流的分布式缓存系统是redis，之前比较有名的有memcached
* 分布式缓存系统一般使用key-value的方式来存储数据库。
* 使用高效的算法来设计存储数据结构，使得基于key的数据项查询时间复杂度达到O(1)，意味着不论存储多少数据项，查询任何数据项所花费的时间不变。
* 数据项过期时间：当缓存区没有足够空间存储新的缓存时，采用淘汰机制来淘汰最近不常用的数据项；但一般动态内容设计时要设置过期时间，可以规避这个问题。
* 对象序列化：将抽象数据类型（数组、对象）转化为二进制字符串，以便通过网络进入缓存服务器，在读取时又将二进制字符串转换成原有数据类型。一般使用JSON格式的字符串与抽象数据类型进行转换。

## 缓存应用场景
* 对于一个数据库写操作频繁的站点来说，可以通过引入缓存来减少写数据库的次数。
* 锁竞争：举一个例子，从缓存服务器上取回数值，本地累加1，接下来写回服务器，会有数据冲突使得累计访问量总是小于实际访问量。要保证运算可以准确进行，要考虑事务隔离机制，可以使用锁竞争，将锁保存在对应数据上，存在竞争关系的动态内容可以争夺这个锁，一旦某个会话，其他会话就必须等待。

## 缓存扩展
实际应用中随着业务的发展经常会遇到需要扩展缓存规模的情况，包括并发处理能力和缓存空间容量等。一般通过增加新的缓存服务器来达到扩展的目的，这时就会存在如何均衡的将缓存数据分布在多台缓存服务器上。1）可以根据业务逻辑进行分布，将每个缓存服务器和对应的子站点域名维护成一个一对多的映射表；2）当业务需要更多缓存规模时再使用方法1就会比较混乱了，可以基于key的划分方式将所有数据项的key均衡分配在n台缓存服务器上，使用“取余”运算。
问题1：散列算法