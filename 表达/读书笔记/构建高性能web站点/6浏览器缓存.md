# 浏览器缓存
### 浏览器不只是用户的
这里提出了一个思想，可以把浏览器想象成WEB站点分派到千万用户的缓存管理器，可以高效的利用起来。
### 缓存放在哪里
浏览器一般会在用户文件系统中创建一个目录用于存放缓存文件，并给缓存文件打上一些标记，例如过期时间。
例如谷歌浏览器缓存文件夹在【/Users/XXX/Library/Caches/Google/Chrome/Default/Cache】中，可以看到里面有很多二进制文件

### 缓存协商
* 当浏览器向web服务器发出请求时，web服务器需要告诉浏览器哪些内容可以缓存；
* 浏览器知道某个内容可以缓存后，下次当浏览器需要请求这个内容时，便不会直接向服务器请求完整内容，而是询问服务器是否可以使用本地缓存
* 服务器再收到浏览器的询问后需要作出响应是否使用本地缓存。

值得注意的是，一般浏览器缓存只针对GET请求，对于POST请求不会启用本地缓存。
1.Last-Modify主动询问协商
Last-Modify：服务器上文件的最后修改时间，一般在HTTP响应中返回
If-Modify-Since:存在于HTTP请求头中，询问服务器请求的内容在这个时间之后是否有更新？
304 Not Modified：服务器告知浏览器请求的内容没有更新，可以使用缓存内容，同时web服务器没有传正文给浏览器。
2.使用ETag协商，ETag是一串编码来标记内容，如果一个内容没有更新，它的ETag也不会变化。
If-None-Match:存在于HTTP请求头中，来询问服务器该内容是否发生变化，如果相同则返回304，不同则将最新内容传给浏览器。一般对文件内容计算md5值作为ETag。

一般来说，浏览器缓存带来的价值不是在于吞吐率的提升，相对于服务器缓存来说浏览器缓存对吞吐率的提升有些微不足道了，它的价值在于大大降低了带宽的使用。当响应正文很大的时候，浏览器缓存对于吞吐率提升的贡献也非常显著，但一般在实际应用中会避免这种情况出现。



expires:浏览器缓存截止时间，告诉浏览器该内容什么时候过期，在过期之前都不需要询问服务器，直接使用缓存即可。

对于常见静态文件格式，即使服务器返回的响应头没有expires字段，也会根据其他线索来猜测一个过期时间，例如IE将gif文件设为永不过期，尽可能避免向服务器发送请求。

#### 如何请求页面

- ctrl+f5强制刷新：强制刷新，不去进行缓存协商，直接加载页面所有的数据，获取页面上所有内容的最新版本；

- f5/点刷新按钮：普通刷新，允许浏览器在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存，也就是Last-Modify可以生效，expires无效；

- 输入url后点击转到/直接回车：允许浏览器以最少请求的方式来获取页面数据，浏览器可以使用未过期的本地缓存，expires是有效的。

所以有时候直接打开页面没有更新成开发同学刚发布的内容，刷新一下就有了，是因为前者还在读本地缓存。

#### 性能

浏览器读取本地缓存的速度**取决于用户PC 的内存和磁盘性能**，因为浏览器会将缓存内容放在磁盘或内存中，从刚才的HttpWatch 跟踪中我们已经看到，当直接使用浏览器缓存时，获取内容的时间为0。

